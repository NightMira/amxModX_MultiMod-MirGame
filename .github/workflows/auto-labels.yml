name: Auto Label Issues and PRs

on:
  workflow_dispatch:
  issues:
    types: [opened, edited]
  pull_request:
    types: [opened, edited, synchronize]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  auto-label:
    runs-on: ubuntu-latest
    steps:
      - name: üöÄ Checkout code (with private token)
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: üè∑Ô∏è Auto-label issues and PRs (using existing labels)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PRIVATE_REPO_TOKEN }}
          script: |
            try {
              const issueData = context.payload.issue;
              const prData = context.payload.pull_request;
              
              if (!issueData && !prData) {
                console.log('‚ùå No issue or PR data found');
                return;
              }

              const target = issueData || prData;
              const { title, body, number, labels = [] } = target;
              const type = issueData ? 'issue' : 'pull_request';

              if (!title) {
                console.log(`‚ö†Ô∏è No title found for ${type} #${number}`);
                return;
              }

              console.log(`üìã Processing ${type}: "${title}" (#${number})`);

              const content = `${title} ${body || ''}`.toLowerCase();
              const currentLabels = new Set(labels.map(label => label.name));

              // üìã Task types - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∏–º–µ–Ω–∞ –º–µ—Ç–æ–∫ –∏–∑ labels.yml
              if (content.includes('bug') || content.includes('–æ—à–∏–±–∫–∞') || content.includes('error') || content.includes('fix') || content.includes('–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ') || content.includes('–±–∞–≥')) {
                currentLabels.add('bug');
              }

              if (content.includes('feature') || content.includes('—Ñ—É–Ω–∫—Ü–∏—è') || content.includes('—É–ª—É—á—à–µ–Ω–∏–µ') || content.includes('–Ω–æ–≤–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å') || content.includes('–¥–æ–±–∞–≤–∏—Ç—å')) {
                currentLabels.add('feature');
              }

              if (content.includes('refactor') || content.includes('—Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥') || content.includes('–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è') || content.includes('–ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∫–∞')) {
                currentLabels.add('refactor');
              }

              if (content.includes('build') || content.includes('—Å–±–æ—Ä–∫–∞') || content.includes('ci/cd') || content.includes('compile') || content.includes('–∫–æ–º–ø–∏–ª—è—Ü–∏—è')) {
                currentLabels.add('build');
              }

              if (content.includes('doc') || content.includes('documentation') || content.includes('–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è') || content.includes('readme') || content.includes('–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è')) {
                currentLabels.add('docs');
              }

              if (content.includes('test') || content.includes('—Ç–µ—Å—Ç') || content.includes('testing') || content.includes('—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ')) {
                currentLabels.add('test');
              }

              // üö® Priorities
              if (content.includes('critical') || content.includes('–∫—Ä–∏—Ç–∏—á') || content.includes('–±–ª–æ–∫–∏—Ä') || content.includes('—Å—Ä–æ—á–Ω–æ') || content.includes('–∞–≤–∞—Ä–∏–π')) {
                currentLabels.add('priority-critical');
              } else if (content.includes('high') || content.includes('–≤—ã—Å–æ–∫') || content.includes('–≤–∞–∂–Ω') || content.includes('–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç')) {
                currentLabels.add('priority-high');
              } else if (content.includes('medium') || content.includes('—Å—Ä–µ–¥–Ω') || content.includes('–æ–±—ã—á–Ω')) {
                currentLabels.add('priority-medium');
              } else if (content.includes('low') || content.includes('–Ω–∏–∑–∫') || content.includes('—É–ª—É—á—à–µ–Ω') || content.includes('–Ω–µ–≤–∞–∂–Ω')) {
                currentLabels.add('priority-low');
              }

              // üîß Components
              if (content.includes('compiler') || content.includes('–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä') || content.includes('amxxpc') || content.includes('amxx')) {
                currentLabels.add('component-compiler');
              }

              if (content.includes('ci/cd') || content.includes('pipeline') || content.includes('github action') || content.includes('workflow') || content.includes('–∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è')) {
                currentLabels.add('component-ci-cd');
              }

              if (content.includes('plugin') || content.includes('–ø–ª–∞–≥–∏–Ω') || content.includes('.sma') || content.includes('.amxx') || content.includes('–º–æ–¥—É–ª—å')) {
                currentLabels.add('component-plugins');
              }

              if (content.includes('doc') || content.includes('–¥–æ–∫—É–º–µ–Ω—Ç') || content.includes('readme') || content.includes('wiki') || content.includes('–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è')) {
                currentLabels.add('component-docs');
              }

              // üè∑Ô∏è Versioning
              if (content.includes('major') || content.includes('–º–∞–∂–æ—Ä') || content.includes('x.0.0')) {
                currentLabels.add('version-major');
              }

              if (content.includes('minor') || content.includes('–º–∏–Ω–æ—Ä') || content.includes('0.y.0')) {
                currentLabels.add('version-minor');
              }

              if (content.includes('patch') || content.includes('–ø–∞—Ç—á') || content.includes('0.0.z') || content.includes('hotfix') || content.includes('–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ')) {
                currentLabels.add('version-patch');
              }

              // üöÄ Release stages
              if (content.includes('dev') || content.includes('—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞') || content.includes('development')) {
                currentLabels.add('stage-dev');
              }

              if (content.includes('alpha') || content.includes('–∞–ª—å—Ñ–∞')) {
                currentLabels.add('stage-alpha');
              }

              if (content.includes('beta') || content.includes('–±–µ—Ç–∞')) {
                currentLabels.add('stage-beta');
              }

              if (content.includes('rc') || content.includes('release candidate') || content.includes('—Ä–µ–ª–∏–∑-–∫–∞–Ω–¥–∏–¥–∞—Ç')) {
                currentLabels.add('stage-rc');
              }

              if (content.includes('release') || content.includes('—Ä–µ–ª–∏–∑') || content.includes('production') || content.includes('–ø—Ä–æ–¥–∞–∫—à–µ–Ω')) {
                currentLabels.add('stage-release');
              }

              if (content.includes('hotfix') || content.includes('—Ö–æ—Ç—Ñ–∏–∫—Å') || content.includes('—Å—Ä–æ—á–Ω–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ')) {
                currentLabels.add('stage-hotfix');
              }

              // –î–ª—è PR –¥–æ–±–∞–≤–ª—è–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –º–µ—Ç–∫–∏
              if (prData) {
                currentLabels.add('component-plugins');
                
                const { additions, deletions } = prData;
                const totalChanges = additions + deletions;
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ø–æ —Ä–∞–∑–º–µ—Ä—É –∏–∑–º–µ–Ω–µ–Ω–∏–π
                if (totalChanges > 500) {
                  currentLabels.add('priority-critical');
                } else if (totalChanges > 200) {
                  currentLabels.add('priority-high');
                } else if (totalChanges > 50) {
                  currentLabels.add('priority-medium');
                } else if (totalChanges > 0) {
                  currentLabels.add('priority-low');
                }

                // –î–æ–±–∞–≤–ª—è–µ–º stage-dev –¥–ª—è PR –≤ dev –≤–µ—Ç–∫—É
                const baseRef = prData.base.ref.toLowerCase();
                if (baseRef === 'dev') {
                  currentLabels.add('stage-dev');
                }
              }

              const labelsToAdd = Array.from(currentLabels);

              if (labelsToAdd.length > 0) {
                console.log(`üè∑Ô∏è Setting existing labels: ${labelsToAdd.join(', ')}`);
                
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º setLabels –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –º–µ—Ç–æ–∫
                await github.rest.issues.setLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: number,
                  labels: labelsToAdd
                });
                
                console.log('‚úÖ Existing labels assigned successfully');
              } else {
                console.log('‚ÑπÔ∏è No matching labels to add');
              }

            } catch (error) {
              console.error('üí• Error in auto-label workflow:', error.message);
              console.log('‚ö†Ô∏è Make sure all labels exist in the repository first');
            }

      - name: üìã Verify labels exist
        env:
          GH_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}
        run: |
          echo "üîç Checking if required labels exist..."
          gh label list
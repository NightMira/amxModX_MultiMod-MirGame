name: Auto Label Issues and PRs

on:
  workflow_dispatch:
    inputs:
      retroactive:
        description: 'Process existing issues and PRs'
        required: false 
        default: false
        type: boolean
  issues:
    types: [opened, edited]
  pull_request:
    types: [opened, edited, synchronize, ready_for_review]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  auto-label:
    runs-on: ubuntu-latest
    steps:
      - name: 🚀 Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: 🏷️ Auto-label new issues and PRs
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event_name == 'workflow_dispatch' && github.event.inputs.retroactive == false) }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PRIVATE_REPO_TOKEN }}
          script: |
            try {
              const issueData = context.payload.issue;
              const prData = context.payload.pull_request;
              
              if (!issueData && !prData) {
                console.log('❌ No issue or PR data found');
                return;
              }

              const target = issueData || prData;
              const { title, body, number, labels = [] } = target;
              const type = issueData ? 'issue' : 'pull_request';

              if (!title) {
                console.log(`⚠️ No title found for ${type} #${number}`);
                return;
              }

              console.log(`📋 Processing ${type}: "${title}" (#${number})`);

              const content = `${title} ${body || ''}`.toLowerCase();
              const currentLabels = new Set(labels.map(label => label.name));

              // ==================== 🎯 TASK TYPES ====================
              if (content.includes('bug') || content.includes('ошибка') || content.includes('error') || content.includes('fix') || content.includes('исправление') || content.includes('баг') || content.includes('не работает')) {
                currentLabels.add('type-bug');
              }

              if (content.includes('feature') || content.includes('функция') || content.includes('улучшение') || content.includes('новая возможность') || content.includes('добавить') || content.includes('предложение')) {
                currentLabels.add('type-feature');
              }

              if (content.includes('refactor') || content.includes('рефакторинг') || content.includes('оптимизация') || content.includes('переработка') || content.includes('cleanup')) {
                currentLabels.add('type-refactor');
              }

              if (content.includes('build') || content.includes('сборка') || content.includes('ci/cd') || content.includes('compile') || content.includes('компиляция') || content.includes('pipeline')) {
                currentLabels.add('type-build');
              }

              if (content.includes('doc') || content.includes('documentation') || content.includes('документация') || content.includes('readme') || content.includes('инструкция') || content.includes('wiki')) {
                currentLabels.add('type-docs');
              }

              if (content.includes('test') || content.includes('тест') || content.includes('testing') || content.includes('тестирование') || content.includes('проверка')) {
                currentLabels.add('type-test');
              }

              // ==================== ⚡ PRIORITIES ====================
              if (content.includes('critical') || content.includes('критич') || content.includes('блокир') || content.includes('срочно') || content.includes('аварий') || content.includes('urgent')) {
                currentLabels.add('priority-critical');
              } else if (content.includes('high') || content.includes('высок') || content.includes('важн') || content.includes('приоритет') || content.includes('important')) {
                currentLabels.add('priority-high');
              } else if (content.includes('medium') || content.includes('средн') || content.includes('обычн') || content.includes('normal')) {
                currentLabels.add('priority-medium');
              } else if (content.includes('low') || content.includes('низк') || content.includes('улучшен') || content.includes('неважн') || content.includes('minor')) {
                currentLabels.add('priority-low');
              }

              // ==================== 🧩 COMPONENTS ====================
              if (content.includes('compiler') || content.includes('компилятор') || content.includes('amxxpc') || content.includes('amxx') || content.includes('сборк')) {
                currentLabels.add('component-compiler');
              }

              if (content.includes('ci/cd') || content.includes('pipeline') || content.includes('github action') || content.includes('workflow') || content.includes('автоматизация') || content.includes('action')) {
                currentLabels.add('component-ci-cd');
              }

              if (content.includes('plugin') || content.includes('плагин') || content.includes('.sma') || content.includes('.amxx') || content.includes('модуль') || content.includes('script')) {
                currentLabels.add('component-plugins');
              }

              if (content.includes('doc') || content.includes('документ') || content.includes('readme') || content.includes('wiki') || content.includes('инструкция') || content.includes('guide')) {
                currentLabels.add('component-docs');
              }

              if (content.includes('version') || content.includes('версия') || content.includes('semver') || content.includes('release') || content.includes('версионирование')) {
                currentLabels.add('component-versioning');
              }

              // ==================== 📊 VERSIONING ====================
              if (content.includes('major') || content.includes('мажор') || content.includes('x.0.0') || content.includes('breaking')) {
                currentLabels.add('version-major');
              }

              if (content.includes('minor') || content.includes('минор') || content.includes('0.y.0') || content.includes('feature')) {
                currentLabels.add('version-minor');
              }

              if (content.includes('patch') || content.includes('патч') || content.includes('0.0.z') || content.includes('hotfix') || content.includes('исправление') || content.includes('bugfix')) {
                currentLabels.add('version-patch');
              }

              // ==================== 🚀 RELEASE STAGES ====================
              if (content.includes('dev') || content.includes('разработка') || content.includes('development') || content.includes('wip')) {
                currentLabels.add('stage-dev');
              }

              if (content.includes('alpha') || content.includes('альфа') || content.includes('test')) {
                currentLabels.add('stage-alpha');
              }

              if (content.includes('beta') || content.includes('бета') || content.includes('testing')) {
                currentLabels.add('stage-beta');
              }

              if (content.includes('rc') || content.includes('release candidate') || content.includes('релиз-кандидат') || content.includes('pre-release')) {
                currentLabels.add('stage-rc');
              }

              if (content.includes('release') || content.includes('релиз') || content.includes('production') || content.includes('продакшен') || content.includes('final')) {
                currentLabels.add('stage-release');
              }

              if (content.includes('hotfix') || content.includes('хотфикс') || content.includes('срочное исправление') || content.includes('emergency')) {
                currentLabels.add('stage-hotfix');
              }

              // ==================== 🔄 PR-SPECIFIC LOGIC ====================
              if (prData) {
                currentLabels.add('component-plugins');
                
                const { additions, deletions } = prData;
                const totalChanges = additions + deletions;
                
                if (totalChanges > 500) {
                  currentLabels.add('priority-critical');
                } else if (totalChanges > 200) {
                  currentLabels.add('priority-high');
                } else if (totalChanges > 50) {
                  currentLabels.add('priority-medium');
                } else if (totalChanges > 0) {
                  currentLabels.add('priority-low');
                }

                const baseRef = prData.base.ref.toLowerCase();
                if (baseRef === 'main') {
                  currentLabels.add('stage-release');
                } else if (baseRef === 'dev') {
                  currentLabels.add('stage-dev');
                } else if (baseRef.includes('alpha')) {
                  currentLabels.add('stage-alpha');
                } else if (baseRef.includes('beta')) {
                  currentLabels.add('stage-beta');
                } else if (baseRef.includes('rc')) {
                  currentLabels.add('stage-rc');
                } else if (baseRef.includes('hotfix')) {
                  currentLabels.add('stage-hotfix');
                }

                currentLabels.add('workflow-needs-review');
              }

              // ==================== 🎯 ISSUE-SPECIFIC LOGIC ====================
              if (issueData) {
                currentLabels.add('workflow-auto');
              }

              const labelsToAdd = Array.from(currentLabels);

              if (labelsToAdd.length > 0) {
                console.log(`🏷️ Setting labels: ${labelsToAdd.join(', ')}`);
                
                await github.rest.issues.setLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: number,
                  labels: labelsToAdd
                });
                
                const summary = `
                ## 🏷️ Auto-Label Summary
                
                ### 📋 ${type.toUpperCase()} Information
                - **Number:** #${number}
                - **Title:** ${title}
                - **Type:** ${type}
                
                ### 📊 Labels Applied
                ${labelsToAdd.map(label => `- \`${label}\``).join('\n')}
                
                ### 🔍 Content Analysis
                Content processed for keyword matching.
                
                *Auto-labeled at ${new Date().toLocaleString()}*
                `;
                
                const fs = require('fs');
                fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
                
                console.log('✅ Labels updated successfully');
              } else {
                console.log('ℹ️ No labels to add');
                
                const summary = `
                ## 🏷️ Auto-Label Summary
                
                ### 📋 ${type.toUpperCase()} Information
                - **Number:** #${number}
                - **Title:** ${title}
                - **Type:** ${type}
                
                ### ℹ️ No Labels Applied
                No matching labels found based on content analysis.
                
                *Processed at ${new Date().toLocaleString()}*
                `;
                
                const fs = require('fs');
                fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
              }

            } catch (error) {
              console.error('💥 Error in auto-label workflow:', error.message);
              
              const summary = `
              ## 🏷️ Auto-Label Summary
              
              ### ❌ Error Occurred
              ${error.message}
              
              *Failed at ${new Date().toLocaleString()}*
              `;
              
              const fs = require('fs');
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
            }

      - name: 🔍 Process existing issues and PRs
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.retroactive == true }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PRIVATE_REPO_TOKEN }}
          script: |
            try {
              console.log('🔍 Starting retroactive labeling of existing issues and PRs...');
              
              // Функция для обработки отдельного issue/PR
              const processItem = async (item, type) => {
                const { title, body, number, labels = [], state } = item;
                
                // Пропускаем закрытые items
                if (state === 'closed') {
                  console.log(`⏭️ Skipping closed ${type} #${number}`);
                  return;
                }

                console.log(`📋 Processing ${type} #${number}: "${title}"`);

                const content = `${title} ${body || ''}`.toLowerCase();
                const currentLabels = new Set(labels.map(label => label.name));

                // TASK TYPES
                if (content.includes('bug') || content.includes('ошибка') || content.includes('error') || content.includes('fix') || content.includes('исправление') || content.includes('баг') || content.includes('не работает')) {
                  currentLabels.add('type-bug');
                }
                if (content.includes('feature') || content.includes('функция') || content.includes('улучшение') || content.includes('новая возможность') || content.includes('добавить') || content.includes('предложение')) {
                  currentLabels.add('type-feature');
                }
                if (content.includes('refactor') || content.includes('рефакторинг') || content.includes('оптимизация') || content.includes('переработка') || content.includes('cleanup')) {
                  currentLabels.add('type-refactor');
                }
                if (content.includes('build') || content.includes('сборка') || content.includes('ci/cd') || content.includes('compile') || content.includes('компиляция') || content.includes('pipeline')) {
                  currentLabels.add('type-build');
                }
                if (content.includes('doc') || content.includes('documentation') || content.includes('документация') || content.includes('readme') || content.includes('инструкция') || content.includes('wiki')) {
                  currentLabels.add('type-docs');
                }
                if (content.includes('test') || content.includes('тест') || content.includes('testing') || content.includes('тестирование') || content.includes('проверка')) {
                  currentLabels.add('type-test');
                }

                // PRIORITIES
                if (content.includes('critical') || content.includes('критич') || content.includes('блокир') || content.includes('срочно') || content.includes('аварий') || content.includes('urgent')) {
                  currentLabels.add('priority-critical');
                } else if (content.includes('high') || content.includes('высок') || content.includes('важн') || content.includes('приоритет') || content.includes('important')) {
                  currentLabels.add('priority-high');
                } else if (content.includes('medium') || content.includes('средн') || content.includes('обычн') || content.includes('normal')) {
                  currentLabels.add('priority-medium');
                } else if (content.includes('low') || content.includes('низк') || content.includes('улучшен') || content.includes('неважн') || content.includes('minor')) {
                  currentLabels.add('priority-low');
                }

                // COMPONENTS
                if (content.includes('compiler') || content.includes('компилятор') || content.includes('amxxpc') || content.includes('amxx') || content.includes('сборк')) {
                  currentLabels.add('component-compiler');
                }
                if (content.includes('ci/cd') || content.includes('pipeline') || content.includes('github action') || content.includes('workflow') || content.includes('автоматизация') || content.includes('action')) {
                  currentLabels.add('component-ci-cd');
                }
                if (content.includes('plugin') || content.includes('плагин') || content.includes('.sma') || content.includes('.amxx') || content.includes('модуль') || content.includes('script')) {
                  currentLabels.add('component-plugins');
                }
                if (content.includes('doc') || content.includes('документ') || content.includes('readme') || content.includes('wiki') || content.includes('инструкция') || content.includes('guide')) {
                  currentLabels.add('component-docs');
                }
                if (content.includes('version') || content.includes('версия') || content.includes('semver') || content.includes('release') || content.includes('версионирование')) {
                  currentLabels.add('component-versioning');
                }

                // Для PR добавляем специфичные метки
                if (type === 'pull_request') {
                  currentLabels.add('component-plugins');
                  currentLabels.add('workflow-needs-review');
                } else {
                  currentLabels.add('workflow-auto');
                }

                const labelsToAdd = Array.from(currentLabels);

                if (labelsToAdd.length > labels.length) {
                  console.log(`🏷️ Setting labels for ${type} #${number}: ${labelsToAdd.join(', ')}`);
                  
                  await github.rest.issues.setLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: number,
                    labels: labelsToAdd
                  });
                  
                  // Пауза чтобы не превысить лимиты API
                  await new Promise(resolve => setTimeout(resolve, 300));
                }
              };

              // Получаем все открытые issues
              console.log('📦 Fetching open issues...');
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // Получаем все открытые PR
              console.log('📦 Fetching open pull requests...');
              const { data: pullRequests } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // Обрабатываем issues
              let processedCount = 0;
              for (const issue of issues) {
                if (!issue.pull_request) {
                  await processItem(issue, 'issue');
                  processedCount++;
                }
              }

              // Обрабатываем PR
              for (const pr of pullRequests) {
                await processItem(pr, 'pull_request');
                processedCount++;
              }

              console.log(`✅ Processed ${processedCount} items`);

              const summary = `
              ## 🔍 Retroactive Labeling Complete
              
              ### 📊 Processing Summary
              - **Total processed:** ${processedCount} items
              - **Issues:** ${issues.filter(i => !i.pull_request).length}
              - **Pull Requests:** ${pullRequests.length}
              
              ### ⏰ Timestamp
              ${new Date().toLocaleString()}
              
              *Automatically processed existing issues and PRs*
              `;
              
              const fs = require('fs');
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);

            } catch (error) {
              console.error('💥 Error in retroactive labeling:', error.message);
              
              const summary = `
              ## 🔍 Retroactive Labeling Failed
              
              ### ❌ Error Occurred
              ${error.message}
              
              *Failed at ${new Date().toLocaleString()}*
              `;
              
              const fs = require('fs');
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
            }
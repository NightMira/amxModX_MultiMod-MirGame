name: Auto Label Issues and PRs

on:
  workflow_dispatch:
    inputs:
      retroactive:
        description: 'Process existing issues and PRs'
        required: false 
        default: false
        type: boolean
  issues:
    types: [opened, edited]
  pull_request:
    types: [opened, edited, synchronize, ready_for_review]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  auto-label:
    runs-on: ubuntu-latest
    steps:
      - name: üöÄ Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: üè∑Ô∏è Auto-label new issues and PRs
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event_name == 'workflow_dispatch' && github.event.inputs.retroactive == false) }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PRIVATE_REPO_TOKEN }}
          script: |
            try {
              const issueData = context.payload.issue;
              const prData = context.payload.pull_request;
              
              if (!issueData && !prData) {
                console.log('‚ùå No issue or PR data found');
                return;
              }

              const target = issueData || prData;
              const { title, body, number, labels = [] } = target;
              const type = issueData ? 'issue' : 'pull_request';

              if (!title) {
                console.log(`‚ö†Ô∏è No title found for ${type} #${number}`);
                return;
              }

              console.log(`üìã Processing ${type}: "${title}" (#${number})`);

              const content = `${title} ${body || ''}`.toLowerCase();
              const currentLabels = new Set(labels.map(label => label.name));

              // ==================== üéØ TASK TYPES ====================
              if (content.includes('bug') || content.includes('–æ—à–∏–±–∫–∞') || content.includes('error') || content.includes('fix') || content.includes('–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ') || content.includes('–±–∞–≥') || content.includes('–Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç')) {
                currentLabels.add('type-bug');
              }

              if (content.includes('feature') || content.includes('—Ñ—É–Ω–∫—Ü–∏—è') || content.includes('—É–ª—É—á—à–µ–Ω–∏–µ') || content.includes('–Ω–æ–≤–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å') || content.includes('–¥–æ–±–∞–≤–∏—Ç—å') || content.includes('–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ')) {
                currentLabels.add('type-feature');
              }

              if (content.includes('refactor') || content.includes('—Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥') || content.includes('–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è') || content.includes('–ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∫–∞') || content.includes('cleanup')) {
                currentLabels.add('type-refactor');
              }

              if (content.includes('build') || content.includes('—Å–±–æ—Ä–∫–∞') || content.includes('ci/cd') || content.includes('compile') || content.includes('–∫–æ–º–ø–∏–ª—è—Ü–∏—è') || content.includes('pipeline')) {
                currentLabels.add('type-build');
              }

              if (content.includes('doc') || content.includes('documentation') || content.includes('–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è') || content.includes('readme') || content.includes('–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è') || content.includes('wiki')) {
                currentLabels.add('type-docs');
              }

              if (content.includes('test') || content.includes('—Ç–µ—Å—Ç') || content.includes('testing') || content.includes('—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ') || content.includes('–ø—Ä–æ–≤–µ—Ä–∫–∞')) {
                currentLabels.add('type-test');
              }

              // ==================== ‚ö° PRIORITIES ====================
              if (content.includes('critical') || content.includes('–∫—Ä–∏—Ç–∏—á') || content.includes('–±–ª–æ–∫–∏—Ä') || content.includes('—Å—Ä–æ—á–Ω–æ') || content.includes('–∞–≤–∞—Ä–∏–π') || content.includes('urgent')) {
                currentLabels.add('priority-critical');
              } else if (content.includes('high') || content.includes('–≤—ã—Å–æ–∫') || content.includes('–≤–∞–∂–Ω') || content.includes('–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç') || content.includes('important')) {
                currentLabels.add('priority-high');
              } else if (content.includes('medium') || content.includes('—Å—Ä–µ–¥–Ω') || content.includes('–æ–±—ã—á–Ω') || content.includes('normal')) {
                currentLabels.add('priority-medium');
              } else if (content.includes('low') || content.includes('–Ω–∏–∑–∫') || content.includes('—É–ª—É—á—à–µ–Ω') || content.includes('–Ω–µ–≤–∞–∂–Ω') || content.includes('minor')) {
                currentLabels.add('priority-low');
              }

              // ==================== üß© COMPONENTS ====================
              if (content.includes('compiler') || content.includes('–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä') || content.includes('amxxpc') || content.includes('amxx') || content.includes('—Å–±–æ—Ä–∫')) {
                currentLabels.add('component-compiler');
              }

              if (content.includes('ci/cd') || content.includes('pipeline') || content.includes('github action') || content.includes('workflow') || content.includes('–∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è') || content.includes('action')) {
                currentLabels.add('component-ci-cd');
              }

              if (content.includes('plugin') || content.includes('–ø–ª–∞–≥–∏–Ω') || content.includes('.sma') || content.includes('.amxx') || content.includes('–º–æ–¥—É–ª—å') || content.includes('script')) {
                currentLabels.add('component-plugins');
              }

              if (content.includes('doc') || content.includes('–¥–æ–∫—É–º–µ–Ω—Ç') || content.includes('readme') || content.includes('wiki') || content.includes('–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è') || content.includes('guide')) {
                currentLabels.add('component-docs');
              }

              if (content.includes('version') || content.includes('–≤–µ—Ä—Å–∏—è') || content.includes('semver') || content.includes('release') || content.includes('–≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ')) {
                currentLabels.add('component-versioning');
              }

              // ==================== üìä VERSIONING ====================
              if (content.includes('major') || content.includes('–º–∞–∂–æ—Ä') || content.includes('x.0.0') || content.includes('breaking')) {
                currentLabels.add('version-major');
              }

              if (content.includes('minor') || content.includes('–º–∏–Ω–æ—Ä') || content.includes('0.y.0') || content.includes('feature')) {
                currentLabels.add('version-minor');
              }

              if (content.includes('patch') || content.includes('–ø–∞—Ç—á') || content.includes('0.0.z') || content.includes('hotfix') || content.includes('–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ') || content.includes('bugfix')) {
                currentLabels.add('version-patch');
              }

              // ==================== üöÄ RELEASE STAGES ====================
              if (content.includes('dev') || content.includes('—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞') || content.includes('development') || content.includes('wip')) {
                currentLabels.add('stage-dev');
              }

              if (content.includes('alpha') || content.includes('–∞–ª—å—Ñ–∞') || content.includes('test')) {
                currentLabels.add('stage-alpha');
              }

              if (content.includes('beta') || content.includes('–±–µ—Ç–∞') || content.includes('testing')) {
                currentLabels.add('stage-beta');
              }

              if (content.includes('rc') || content.includes('release candidate') || content.includes('—Ä–µ–ª–∏–∑-–∫–∞–Ω–¥–∏–¥–∞—Ç') || content.includes('pre-release')) {
                currentLabels.add('stage-rc');
              }

              if (content.includes('release') || content.includes('—Ä–µ–ª–∏–∑') || content.includes('production') || content.includes('–ø—Ä–æ–¥–∞–∫—à–µ–Ω') || content.includes('final')) {
                currentLabels.add('stage-release');
              }

              if (content.includes('hotfix') || content.includes('—Ö–æ—Ç—Ñ–∏–∫—Å') || content.includes('—Å—Ä–æ—á–Ω–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ') || content.includes('emergency')) {
                currentLabels.add('stage-hotfix');
              }

              // ==================== üîÑ PR-SPECIFIC LOGIC ====================
              if (prData) {
                currentLabels.add('component-plugins');
                
                const { additions, deletions } = prData;
                const totalChanges = additions + deletions;
                
                if (totalChanges > 500) {
                  currentLabels.add('priority-critical');
                } else if (totalChanges > 200) {
                  currentLabels.add('priority-high');
                } else if (totalChanges > 50) {
                  currentLabels.add('priority-medium');
                } else if (totalChanges > 0) {
                  currentLabels.add('priority-low');
                }

                const baseRef = prData.base.ref.toLowerCase();
                if (baseRef === 'main') {
                  currentLabels.add('stage-release');
                } else if (baseRef === 'dev') {
                  currentLabels.add('stage-dev');
                } else if (baseRef.includes('alpha')) {
                  currentLabels.add('stage-alpha');
                } else if (baseRef.includes('beta')) {
                  currentLabels.add('stage-beta');
                } else if (baseRef.includes('rc')) {
                  currentLabels.add('stage-rc');
                } else if (baseRef.includes('hotfix')) {
                  currentLabels.add('stage-hotfix');
                }

                currentLabels.add('workflow-needs-review');
              }

              // ==================== üéØ ISSUE-SPECIFIC LOGIC ====================
              if (issueData) {
                currentLabels.add('workflow-auto');
              }

              const labelsToAdd = Array.from(currentLabels);

              if (labelsToAdd.length > 0) {
                console.log(`üè∑Ô∏è Setting labels: ${labelsToAdd.join(', ')}`);
                
                await github.rest.issues.setLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: number,
                  labels: labelsToAdd
                });
                
                const summary = `
                ## üè∑Ô∏è Auto-Label Summary
                
                ### üìã ${type.toUpperCase()} Information
                - **Number:** #${number}
                - **Title:** ${title}
                - **Type:** ${type}
                
                ### üìä Labels Applied
                ${labelsToAdd.map(label => `- \`${label}\``).join('\n')}
                
                ### üîç Content Analysis
                Content processed for keyword matching.
                
                *Auto-labeled at ${new Date().toLocaleString()}*
                `;
                
                const fs = require('fs');
                fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
                
                console.log('‚úÖ Labels updated successfully');
              } else {
                console.log('‚ÑπÔ∏è No labels to add');
                
                const summary = `
                ## üè∑Ô∏è Auto-Label Summary
                
                ### üìã ${type.toUpperCase()} Information
                - **Number:** #${number}
                - **Title:** ${title}
                - **Type:** ${type}
                
                ### ‚ÑπÔ∏è No Labels Applied
                No matching labels found based on content analysis.
                
                *Processed at ${new Date().toLocaleString()}*
                `;
                
                const fs = require('fs');
                fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
              }

            } catch (error) {
              console.error('üí• Error in auto-label workflow:', error.message);
              
              const summary = `
              ## üè∑Ô∏è Auto-Label Summary
              
              ### ‚ùå Error Occurred
              ${error.message}
              
              *Failed at ${new Date().toLocaleString()}*
              `;
              
              const fs = require('fs');
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
            }

      - name: üîç Process existing issues and PRs
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.retroactive == true }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PRIVATE_REPO_TOKEN }}
          script: |
            try {
              console.log('üîç Starting retroactive labeling of existing issues and PRs...');
              
              // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ issue/PR
              const processItem = async (item, type) => {
                const { title, body, number, labels = [], state } = item;
                
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–∫—Ä—ã—Ç—ã–µ items
                if (state === 'closed') {
                  console.log(`‚è≠Ô∏è Skipping closed ${type} #${number}`);
                  return;
                }

                console.log(`üìã Processing ${type} #${number}: "${title}"`);

                const content = `${title} ${body || ''}`.toLowerCase();
                const currentLabels = new Set(labels.map(label => label.name));

                // TASK TYPES
                if (content.includes('bug') || content.includes('–æ—à–∏–±–∫–∞') || content.includes('error') || content.includes('fix') || content.includes('–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ') || content.includes('–±–∞–≥') || content.includes('–Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç')) {
                  currentLabels.add('type-bug');
                }
                if (content.includes('feature') || content.includes('—Ñ—É–Ω–∫—Ü–∏—è') || content.includes('—É–ª—É—á—à–µ–Ω–∏–µ') || content.includes('–Ω–æ–≤–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å') || content.includes('–¥–æ–±–∞–≤–∏—Ç—å') || content.includes('–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ')) {
                  currentLabels.add('type-feature');
                }
                if (content.includes('refactor') || content.includes('—Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥') || content.includes('–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è') || content.includes('–ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∫–∞') || content.includes('cleanup')) {
                  currentLabels.add('type-refactor');
                }
                if (content.includes('build') || content.includes('—Å–±–æ—Ä–∫–∞') || content.includes('ci/cd') || content.includes('compile') || content.includes('–∫–æ–º–ø–∏–ª—è—Ü–∏—è') || content.includes('pipeline')) {
                  currentLabels.add('type-build');
                }
                if (content.includes('doc') || content.includes('documentation') || content.includes('–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è') || content.includes('readme') || content.includes('–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è') || content.includes('wiki')) {
                  currentLabels.add('type-docs');
                }
                if (content.includes('test') || content.includes('—Ç–µ—Å—Ç') || content.includes('testing') || content.includes('—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ') || content.includes('–ø—Ä–æ–≤–µ—Ä–∫–∞')) {
                  currentLabels.add('type-test');
                }

                // PRIORITIES
                if (content.includes('critical') || content.includes('–∫—Ä–∏—Ç–∏—á') || content.includes('–±–ª–æ–∫–∏—Ä') || content.includes('—Å—Ä–æ—á–Ω–æ') || content.includes('–∞–≤–∞—Ä–∏–π') || content.includes('urgent')) {
                  currentLabels.add('priority-critical');
                } else if (content.includes('high') || content.includes('–≤—ã—Å–æ–∫') || content.includes('–≤–∞–∂–Ω') || content.includes('–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç') || content.includes('important')) {
                  currentLabels.add('priority-high');
                } else if (content.includes('medium') || content.includes('—Å—Ä–µ–¥–Ω') || content.includes('–æ–±—ã—á–Ω') || content.includes('normal')) {
                  currentLabels.add('priority-medium');
                } else if (content.includes('low') || content.includes('–Ω–∏–∑–∫') || content.includes('—É–ª—É—á—à–µ–Ω') || content.includes('–Ω–µ–≤–∞–∂–Ω') || content.includes('minor')) {
                  currentLabels.add('priority-low');
                }

                // COMPONENTS
                if (content.includes('compiler') || content.includes('–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä') || content.includes('amxxpc') || content.includes('amxx') || content.includes('—Å–±–æ—Ä–∫')) {
                  currentLabels.add('component-compiler');
                }
                if (content.includes('ci/cd') || content.includes('pipeline') || content.includes('github action') || content.includes('workflow') || content.includes('–∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è') || content.includes('action')) {
                  currentLabels.add('component-ci-cd');
                }
                if (content.includes('plugin') || content.includes('–ø–ª–∞–≥–∏–Ω') || content.includes('.sma') || content.includes('.amxx') || content.includes('–º–æ–¥—É–ª—å') || content.includes('script')) {
                  currentLabels.add('component-plugins');
                }
                if (content.includes('doc') || content.includes('–¥–æ–∫—É–º–µ–Ω—Ç') || content.includes('readme') || content.includes('wiki') || content.includes('–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è') || content.includes('guide')) {
                  currentLabels.add('component-docs');
                }
                if (content.includes('version') || content.includes('–≤–µ—Ä—Å–∏—è') || content.includes('semver') || content.includes('release') || content.includes('–≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ')) {
                  currentLabels.add('component-versioning');
                }

                // –î–ª—è PR –¥–æ–±–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –º–µ—Ç–∫–∏
                if (type === 'pull_request') {
                  currentLabels.add('component-plugins');
                  currentLabels.add('workflow-needs-review');
                } else {
                  currentLabels.add('workflow-auto');
                }

                const labelsToAdd = Array.from(currentLabels);

                if (labelsToAdd.length > labels.length) {
                  console.log(`üè∑Ô∏è Setting labels for ${type} #${number}: ${labelsToAdd.join(', ')}`);
                  
                  await github.rest.issues.setLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: number,
                    labels: labelsToAdd
                  });
                  
                  // –ü–∞—É–∑–∞ —á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ–≤—ã—Å–∏—Ç—å –ª–∏–º–∏—Ç—ã API
                  await new Promise(resolve => setTimeout(resolve, 300));
                }
              };

              // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ issues
              console.log('üì¶ Fetching open issues...');
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ PR
              console.log('üì¶ Fetching open pull requests...');
              const { data: pullRequests } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º issues
              let processedCount = 0;
              for (const issue of issues) {
                if (!issue.pull_request) {
                  await processItem(issue, 'issue');
                  processedCount++;
                }
              }

              // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º PR
              for (const pr of pullRequests) {
                await processItem(pr, 'pull_request');
                processedCount++;
              }

              console.log(`‚úÖ Processed ${processedCount} items`);

              const summary = `
              ## üîç Retroactive Labeling Complete
              
              ### üìä Processing Summary
              - **Total processed:** ${processedCount} items
              - **Issues:** ${issues.filter(i => !i.pull_request).length}
              - **Pull Requests:** ${pullRequests.length}
              
              ### ‚è∞ Timestamp
              ${new Date().toLocaleString()}
              
              *Automatically processed existing issues and PRs*
              `;
              
              const fs = require('fs');
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);

            } catch (error) {
              console.error('üí• Error in retroactive labeling:', error.message);
              
              const summary = `
              ## üîç Retroactive Labeling Failed
              
              ### ‚ùå Error Occurred
              ${error.message}
              
              *Failed at ${new Date().toLocaleString()}*
              `;
              
              const fs = require('fs');
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
            }
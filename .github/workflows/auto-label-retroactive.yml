name: Auto Label Retroactive Check

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * 0'  # –ö–∞–∂–¥–æ–µ –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ –≤ –ø–æ–ª–Ω–æ—á—å
  push:
    branches: [main]
    paths: ['.github/labels.yml']

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  retroactive-labeling:
    runs-on: ubuntu-latest
    steps:
      - name: üöÄ Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: üè∑Ô∏è Process existing issues and PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PRIVATE_REPO_TOKEN }}
          script: |
            try {
              console.log('üîç Starting retroactive labeling of existing issues and PRs...');
              
              // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ issue/PR
              const processItem = async (item, type) => {
                const { title, body, number, labels = [], state } = item;
                
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–∫—Ä—ã—Ç—ã–µ items
                if (state === 'closed') {
                  console.log(`‚è≠Ô∏è Skipping closed ${type} #${number}`);
                  return;
                }

                console.log(`üìã Processing ${type} #${number}: "${title}"`);

                const content = `${title} ${body || ''}`.toLowerCase();
                const currentLabels = new Set(labels.map(label => label.name));

                // ==================== üéØ TASK TYPES ====================
                if (content.includes('bug') || content.includes('–æ—à–∏–±–∫–∞') || content.includes('error') || content.includes('fix') || content.includes('–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ') || content.includes('–±–∞–≥') || content.includes('–Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç')) {
                  currentLabels.add('type-bug');
                }

                if (content.includes('feature') || content.includes('—Ñ—É–Ω–∫—Ü–∏—è') || content.includes('—É–ª—É—á—à–µ–Ω–∏–µ') || content.includes('–Ω–æ–≤–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å') || content.includes('–¥–æ–±–∞–≤–∏—Ç—å') || content.includes('–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ')) {
                  currentLabels.add('type-feature');
                }

                if (content.includes('refactor') || content.includes('—Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥') || content.includes('–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è') || content.includes('–ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∫–∞') || content.includes('cleanup')) {
                  currentLabels.add('type-refactor');
                }

                if (content.includes('build') || content.includes('—Å–±–æ—Ä–∫–∞') || content.includes('ci/cd') || content.includes('compile') || content.includes('–∫–æ–º–ø–∏–ª—è—Ü–∏—è') || content.includes('pipeline')) {
                  currentLabels.add('type-build');
                }

                if (content.includes('doc') || content.includes('documentation') || content.includes('–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è') || content.includes('readme') || content.includes('–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è') || content.includes('wiki')) {
                  currentLabels.add('type-docs');
                }

                if (content.includes('test') || content.includes('—Ç–µ—Å—Ç') || content.includes('testing') || content.includes('—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ') || content.includes('–ø—Ä–æ–≤–µ—Ä–∫–∞')) {
                  currentLabels.add('type-test');
                }

                // ==================== ‚ö° PRIORITIES ====================
                if (content.includes('critical') || content.includes('–∫—Ä–∏—Ç–∏—á') || content.includes('–±–ª–æ–∫–∏—Ä') || content.includes('—Å—Ä–æ—á–Ω–æ') || content.includes('–∞–≤–∞—Ä–∏–π') || content.includes('urgent')) {
                  currentLabels.add('priority-critical');
                } else if (content.includes('high') || content.includes('–≤—ã—Å–æ–∫') || content.includes('–≤–∞–∂–Ω') || content.includes('–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç') || content.includes('important')) {
                  currentLabels.add('priority-high');
                } else if (content.includes('medium') || content.includes('—Å—Ä–µ–¥–Ω') || content.includes('–æ–±—ã—á–Ω') || content.includes('normal')) {
                  currentLabels.add('priority-medium');
                } else if (content.includes('low') || content.includes('–Ω–∏–∑–∫') || content.includes('—É–ª—É—á—à–µ–Ω') || content.includes('–Ω–µ–≤–∞–∂–Ω') || content.includes('minor')) {
                  currentLabels.add('priority-low');
                }

                // ==================== üß© COMPONENTS ====================
                if (content.includes('compiler') || content.includes('–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä') || content.includes('amxxpc') || content.includes('amxx') || content.includes('—Å–±–æ—Ä–∫')) {
                  currentLabels.add('component-compiler');
                }

                if (content.includes('ci/cd') || content.includes('pipeline') || content.includes('github action') || content.includes('workflow') || content.includes('–∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è') || content.includes('action')) {
                  currentLabels.add('component-ci-cd');
                }

                if (content.includes('plugin') || content.includes('–ø–ª–∞–≥–∏–Ω') || content.includes('.sma') || content.includes('.amxx') || content.includes('–º–æ–¥—É–ª—å') || content.includes('script')) {
                  currentLabels.add('component-plugins');
                }

                if (content.includes('doc') || content.includes('–¥–æ–∫—É–º–µ–Ω—Ç') || content.includes('readme') || content.includes('wiki') || content.includes('–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è') || content.includes('guide')) {
                  currentLabels.add('component-docs');
                }

                if (content.includes('version') || content.includes('–≤–µ—Ä—Å–∏—è') || content.includes('semver') || content.includes('release') || content.includes('–≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ')) {
                  currentLabels.add('component-versioning');
                }

                // –î–ª—è PR –¥–æ–±–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –º–µ—Ç–∫–∏
                if (type === 'pull_request') {
                  currentLabels.add('component-plugins');
                  currentLabels.add('workflow-needs-review');
                } else {
                  currentLabels.add('workflow-auto');
                }

                const labelsToAdd = Array.from(currentLabels);

                if (labelsToAdd.length > 0) {
                  console.log(`üè∑Ô∏è Setting labels for ${type} #${number}: ${labelsToAdd.join(', ')}`);
                  
                  await github.rest.issues.setLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: number,
                    labels: labelsToAdd
                  });
                }
              };

              // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ issues
              console.log('üì¶ Fetching open issues...');
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ PR
              console.log('üì¶ Fetching open pull requests...');
              const { data: pullRequests } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º issues
              let processedCount = 0;
              for (const issue of issues) {
                if (!issue.pull_request) { // –¢–æ–ª—å–∫–æ issues, –Ω–µ PR
                  await processItem(issue, 'issue');
                  processedCount++;
                  // –ü–∞—É–∑–∞ —á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ–≤—ã—Å–∏—Ç—å –ª–∏–º–∏—Ç—ã API
                  await new Promise(resolve => setTimeout(resolve, 500));
                }
              }

              // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º PR
              for (const pr of pullRequests) {
                await processItem(pr, 'pull_request');
                processedCount++;
                // –ü–∞—É–∑–∞ —á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ–≤—ã—Å–∏—Ç—å –ª–∏–º–∏—Ç—ã API
                await new Promise(resolve => setTimeout(resolve, 500));
              }

              console.log(`‚úÖ Processed ${processedCount} items`);

              const summary = `
              ## üîç Retroactive Labeling Complete
              
              ### üìä Processing Summary
              - **Total processed:** ${processedCount} items
              - **Issues:** ${issues.filter(i => !i.pull_request).length}
              - **Pull Requests:** ${pullRequests.length}
              
              ### ‚è∞ Timestamp
              ${new Date().toLocaleString()}
              
              *Automatically processed existing issues and PRs*
              `;
              
              const fs = require('fs');
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);

            } catch (error) {
              console.error('üí• Error in retroactive labeling:', error.message);
              
              const summary = `
              ## üîç Retroactive Labeling Failed
              
              ### ‚ùå Error Occurred
              ${error.message}
              
              *Failed at ${new Date().toLocaleString()}*
              `;
              
              const fs = require('fs');
              fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
            }